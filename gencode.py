

import numpy

numpy_type_list = ['NPY_INT8', 'NPY_INT16', 'NPY_INT32', 'NPY_INT64', 'NPY_UINT8', 'NPY_UINT16', 'NPY_UINT32', 'NPY_UINT64', 'NPY_FLOAT32', 'NPY_FLOAT64']

numpy_types = {'NPY_INT8': 'npy_int8', 'NPY_INT16': 'npy_int16', 'NPY_INT32': 'npy_int32', 'NPY_INT64': 'npy_int64', 
               'NPY_UINT8': 'npy_uint8', 'NPY_UINT16': 'npy_uint16', 'NPY_UINT32': 'npy_uint32', 'NPY_UINT64': 'npy_uint64',
               'NPY_FLOAT32': 'npy_float32', 'NPY_FLOAT64': 'npy_float64'}

f = open('generated/thunkops_binarypipeline.c', 'w+')
f.write('/* THIS FILE IS GENERATED BY gencode.py */\n')
f.write('/* DO NOT EDIT THIS FILE MANUALLY */\n')
f.write('#include "../thunkops.h"\n')
f.write('#include "thunkops_binarypipeline.h"\n')

f2 = open('generated/thunkops_binarypipeline.h', 'w+')
f2.write('/* THIS FILE IS GENERATED BY gencode.py */\n')
f2.write('/* DO NOT EDIT THIS FILE MANUALLY */\n\n')

def dictindex(dd, vv):
	for key,value in dd.iteritems():
		if value == vv:
			return key

def create_numpy_array(dtype):
	return {
		numpy_types['NPY_INT8']: numpy.array([1], dtype=numpy.int8),
		numpy_types['NPY_INT16']: numpy.array([1], dtype=numpy.int16),
		numpy_types['NPY_INT32']: numpy.array([1], dtype=numpy.int32),
		numpy_types['NPY_INT64']: numpy.array([1], dtype=numpy.int64),
		numpy_types['NPY_UINT8']: numpy.array([1], dtype=numpy.uint8),
		numpy_types['NPY_UINT16']: numpy.array([1], dtype=numpy.uint16),
		numpy_types['NPY_UINT32']: numpy.array([1], dtype=numpy.uint32),
		numpy_types['NPY_UINT64']: numpy.array([1], dtype=numpy.uint64),
		numpy_types['NPY_FLOAT32']: numpy.array([1], dtype=numpy.float32),
		numpy_types['NPY_FLOAT64']: numpy.array([1], dtype=numpy.float64)
	}[dtype]

def numpy_array_to_ctype(array):
	return {
		numpy.dtype('int8'): numpy_types['NPY_INT8'],
		numpy.dtype('int16'): numpy_types['NPY_INT16'],
		numpy.dtype('int32'): numpy_types['NPY_INT32'],
		numpy.dtype('int64'): numpy_types['NPY_INT64'],
		numpy.dtype('uint8'): numpy_types['NPY_UINT8'],
		numpy.dtype('uint16'): numpy_types['NPY_UINT16'],
		numpy.dtype('uint32'): numpy_types['NPY_UINT32'],
		numpy.dtype('uint64'): numpy_types['NPY_UINT64'],
		numpy.dtype('float32'): numpy_types['NPY_FLOAT32'],
		numpy.dtype('float64'): numpy_types['NPY_FLOAT64'],
	}[array.dtype]

def ctype_to_name(tpe):
	return tpe.replace('unsigned ', 'u').replace(' ', '')

def type_switch(tpe, operator, operatorname,data, prefix):
	res = prefix + '\tswitch(%s) {\n' % tpe
	for numpytype in numpy_type_list:
		ctype = numpy_types[numpytype]
		res += prefix + '\t\tcase %s:\n' % numpytype
		if tpe == 'a_type':
			res += type_switch('b_type', operator, operatorname, data + [ctype], '\t\t')
			res += prefix + '\t\t\tbreak;\n'
		else:
			storage_type = numpy_array_to_ctype(create_numpy_array(data[0]) * create_numpy_array(ctype))
			res += prefix + '\t\t\tfor(size_t i = start; i < end; i++) {\n';
			res += prefix + '\t\t\t\t((%s*)storage)[i] = ((%s*)a)[i] %s ((%s*)b)[i];\n' % (storage_type, data[0], operator, ctype);
			res += prefix + '\t\t\t}\n';
			res += prefix + '\t\t\tbreak;\n'
	res += prefix + '\t}\n'
	return(res)


def generate_binary_operator(operator, operatorname):
	f2.write('void pipeline_%s(void *storage, void *a, void *b, size_t start, size_t end, int a_type, int b_type);\n' % operatorname)
	res = '\nvoid pipeline_%s(void *storage, void *a, void *b, size_t start, size_t end, int a_type, int b_type) {\n' % operatorname
	res += type_switch('a_type', operator, operatorname, [], '')
	res += '}\n'
	f.write(res)


generate_binary_operator('*', 'multiply')
generate_binary_operator('+', 'add')
generate_binary_operator('-', 'subtract')
generate_binary_operator('/', 'divide')

f2.close()
f.close()

f = open('generated/thunkops_unarypipeline.c', 'w+')
f.write('/* THIS FILE IS GENERATED BY gencode.py */\n')
f.write('/* DO NOT EDIT THIS FILE MANUALLY */\n')
f.write('#include "../thunkops.h"\n')
f.write('#include "thunkops_unarypipeline.h"\n')

f2 = open('generated/thunkops_unarypipeline.h', 'w+')
f2.write('/* THIS FILE IS GENERATED BY gencode.py */\n')
f2.write('/* DO NOT EDIT THIS FILE MANUALLY */\n\n')

def generate_unary_function(functionname, returntype, numpyfun):
	f2.write('void pipeline_%s(void *storage, void *a, size_t start, size_t end, int a_type);\n' % functionname)
	res = '\nvoid pipeline_%s(void *storage, void *a, size_t start, size_t end, int a_type) {\n' % functionname
	res += '\tswitch(a_type) {\n'
	for tpe in numpy_type_list:
		restype = numpy_array_to_ctype(numpyfun(create_numpy_array(numpy_types[tpe])))
		res += '\t\tcase %s:\n' % tpe
		res += '\t\t\tfor(size_t i = start; i < end; i++) {\n'
		res += '\t\t\t\t((%s*)storage)[i] = %s(((%s*)a)[i]);\n' % (restype, functionname, numpy_types[tpe])
		res += '\t\t\t}\n'
		res += '\t\t\tbreak;\n'
	res += '\t}\n'
	res += '}\n'
	f.write(res)


generate_unary_function('sqrt', 'double', numpy.sqrt)

f2.close()
f.close()

f = open('generated/thunktypes.c', 'w+')
f.write('/* THIS FILE IS GENERATED BY gencode.py */\n')
f.write('/* DO NOT EDIT THIS FILE MANUALLY */\n')
f.write('#include "../thunktypes.h"\n\n')

f.write('int StandardBinaryTypeResolution(int type, int type2) {\n')
f.write('\tswitch(type) {\n')
for tpe in numpy_type_list:
	f.write('\t\tcase %s:\n' % tpe)
	f.write('\t\tswitch(type2) {\n')
	for tpe2 in numpy_type_list:
		f.write('\t\t\tcase %s: ' % tpe2)
		f.write('return %s;\n' % dictindex(numpy_types, numpy_array_to_ctype(create_numpy_array(numpy_types[tpe]) * create_numpy_array(numpy_types[tpe2]))))
	f.write('\t\t}\n')
f.write('\t}\n')
f.write('\treturn -1;\n')
f.write('}\n\n')

f.write('int FloatUnaryTypeResolution(int type) {\n')
f.write('\tswitch(type) {\n')
for tpe in numpy_type_list:
	f.write('\t\tcase %s: ' % tpe)
	f.write('return %s;\n' % dictindex(numpy_types, numpy_array_to_ctype(numpy.sqrt(create_numpy_array(numpy_types[tpe])))))
f.write('\t}\n')
f.write('\treturn -1;\n')
f.write('}\n')
f.close()